# [Clean Architecture](http://niquola.github.io/happydev-2013-slides/)

My slides for [happydev.2013](http://2013.happydev.ru)

### Что такое АРХИТЕКТУРА?

> Software Architecture as a Set of Architectural Design Decisions

[A. Jansen & J. Bosch](http://new.csd.uwo.ca/courses/CS4471b/secure/Additional%20Resources/020_Architectures.dir/1_WICSA_Confs/WICSA_2005_Pittsburgh/2005_papers/18500111.pdf)

### Решение это часто компромис

Умные люди знают, любое решение имеет обратную сторону (tradeoff)

У монеты две стороны; У палки два конца

* [CAP](http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) & Basically Available, Soft-state, Eventually consistent
* Простота и Гибкость
* Модульность и монолитность

### Это сокрыто в природе вещей

[Три закона диалектики](http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D0%B8#.D0.92_.D0.B4.D0.B8.D0.B0.D0.BB.D0.B5.D0.BA.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.BC_.D0.BC.D0.B0.D1.82.D0.B5.D1.80.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.BC.D0.B5)

*Закон единства и борьбы противоположностей*

> Движение и развитие в природе, обществе и мышлении
> обусловлено раздвоением единого на взаимопроникающие противоположности
> и разрешением возникающих противоречий между ними через борьбу

### Разница только в том насколько осознано вы выбираете

Иногда полезно использовать негативное определение
(ибо в порыве вдохновения о темной стороне часто забывают).

Хорошее решение уменьшает кол-во негативных последствий

>  Основная задача дизайна уменьшить боль, а не увеличить количество ништяков!
>  Нет хорошей или плохой архитектуры - она может быть обоснованной или нет!

[Тренинг «Проектирование обоснованной архитектуры», Евгений Кривошеев](http://jugru.timepad.ru/event/80808/)

### LEAN manufacturing (производственные концепции и практики Toyota)

Делая выбор, порой забывают, что есть еще одна опция - "Отложить этот выбор"

> good architecture maximizes
> the number of decisions
> not made

Robert Martin (Uncle Bob)</h4>

### Архитектура не висит в воздухе

Мы часть бизнесс-механизма, производящего ПО (see [SEMAT](http://semat.org/))

Свое подтверждение архитектура должна выводить из требований
Требования из бизнесс модели

![semat](semat.png)

Принимающие архитектурные решения должны в достаточной степени понимать это.
Например некоторые противоречия могут быть разрешены только уровнем выше.

### System Thinking

Экспоненциальный рост сложности - взаимодействие частей!

Если вы создаете большую и сложную систему,
то надо ее разделять на подсистемы,
каждая из которых должна быть проще и содержать как можно меньше противоречий (SP)
и следить за зависимостями

> Design is taking things apart
> and then compose

[Rich Hickey](http://www.infoq.com/author/Rich-Hickey)

### Немного DDD

> Как правильно разрезать быка?
> По суставчикам

[Domain Driven Design] (http://en.wikipedia.org/wiki/Domain-driven_design) by [Eric Evans](http://www.infoq.com/author/Eric-Evans)

* Bounded Contexts
* Aggregates
* Entities & Value Objects

![context map](context-map.jpg)

## Сложная предметная область (непонятность и не известность)

Если ваш контекст - сложная предметная область или неизвестность, то как быть

Т.е чтобы с ней разобраться вам нужно затратить столько же усилий, сколько вы например уже затратили на IT.
То вы можете впасть в ошибку - ПРЕЖДЕВРЕММЕННОЕ МОДЕЛИРОВАНИЕ (близко к преждевременно оптимизации).

> Преждевременная оптимизация — корень всех зол

Д. Кнут «Structured Programming with go to Statements»

### Behaviour Driven

Важнее то как система себя ведет (внешнии требования)
нежели то как она устроена (внутреннии требования)

### Use Case & Internal Model
Опять диалектика - Induction & Deduction

Есть [два подхода](http://en.wikipedia.org/wiki/Top-down_and_bottom-up_design) (взаимопроникающии).

* Придумать модель и вывести приложение (скорость и магия, большой риск)
* Вывести из приложения модель (низкий риск ошибки, время)

Надо осознанно и своевременно пользоваться обоими по очередно.

Notes about RoR :)

### Как мы описываем систему - Use Case

Use Case -последовательность взаимодействий с системой направленная на достижение цели

Почему бы не отобразить Use Case прямо в код?

### Итак: Use Case Driven

* Use Case - собираем и приоретизируем требования, проверяем их не противоричивость
* Prototype - делаем самую-самую дешевую реализацию и уточняем требование и наше понимание
* Specification - пишем автоматическую спецификацию
* Implementation - пишем работающую реализацию и заходим на второй цикл проверки
* Refactoring to deeper insight - когда находим правильную модель - рефакторим с тестами

### Закон Конвея & Кайдзен
![](kaizen.png)
